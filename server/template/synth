<html>
   <head>
       <title>DubStep Pendulum</title>
       <script type="text/javascript" src="/static/js/jquery-1.10.2.min.js"></script>
       <script type="text/javascript" src="/static/js/socket.io.min.js"></script>
       <script type="text/javascript" src="/static/js/buffer-loader.js"></script>
       <link rel="stylesheet" type="text/css" href="/static/css/bootstrap.css">
   </head>
   <body>

       <a class="btn btn-large" onclick="play()">Play</a>
       <a class="btn btn-large" onclick="pause()">Pause</a>


   </body>
<script>

// For build up, bring up filter freq from 0 - 1000hz
// For drop oscillate, between 0 - 1000Hz
// for fast, oscillate between

var STATE_IDLE  = 0;
var STATE_BUILD = 1;
var STATE_DROP  = 2;
var STATE_FAST  = 3
var state = STATE_IDLE;
var drop_t = 0;

var last_z = -3000, last_x = 0, last_y = 0, sign = 0, last_m;
var idle_threshold = 25;
var idle_loops = 2;
var idle_count = 0;
var state = STATE_IDLE;

var drop_duration = 1;
var drop_threshold = 250;
var drop_loops = 5;
var drop_count = 0;

// Modulation notes: 
// use gain node to scale to 200. 
// use another osc to be the modulating oscilator 

var max_volume = 1.0;
var osc_volume = .2;

var ctx = new AudioContext();

//var osc = ctx.createOscillator()
//osc.type = "square";
//var osc2 = ctx.createOscillator()
//osc2.type = "square";

build_lp = ctx.createBiquadFilter();
build_lp.type = "lowpass";

drop_lp = ctx.createBiquadFilter();
drop_lp.type = "lowpass";

fast_lp = ctx.createBiquadFilter();
fast_lp.type = "lowpass";

var master_gain = ctx.createGain();
var build_gain = ctx.createGain();
var drop_gain = ctx.createGain();
var fast_gain = ctx.createGain();

drop_gain.gain.value = .0;
build_gain.gain.value = .0;
fast_gain.gain.value = .0;


bufferLoader = new BufferLoader(
    ctx,
    [ 'static/wav/build.wav', 'static/wav/drop-bass-1.wav', 'static/wav/drop-bass-2.wav' ],
    finishedLoading
);
bufferLoader.load();

function finishedLoading(bufferList)
{
    master_gain.gain.value = max_volume;

    var build = ctx.createBufferSource(); 
    build.buffer = bufferList[0];               
    build.loop = true;
    build.connect(build_gain);
    build.start(0);                    

    var drop = ctx.createBufferSource(); 
    drop.buffer = bufferList[1];               
    drop.loop = true;
    drop.connect(drop_gain);
    drop_gain.gain.value = 0;
    drop.start(0);                    

    var fast = ctx.createBufferSource(); 
    fast.buffer = bufferList[2];               
    fast.loop = true;
    fast.connect(fast_gain);
    fast_gain.gain.value = 0;
    fast.start(0);                    

    drop_gain.connect(master_gain);
    build_gain.connect(master_gain);
    fast_gain.connect(master_gain);

    master_gain.connect(ctx.destination);
}

function play_sound(buffer, loop) 
{
    var source = ctx.createBufferSource(); 
    source.buffer = buffer;               
    source.loop = loop;
    source.connect(master_gain);
    source.start(0);                    
}

function play()
{
    master_gain.gain.value = max_volume;
}
function pause()
{
    master_gain.gain.value = 0;
}

function handler(t, x, y, z)
{
    if (last_z == -3000)
    {
        last_x = x;
        last_y = y;
        last_z = z;
    }

    if (Math.abs(last_x - x) < idle_threshold &&
        Math.abs(last_y - y) < idle_threshold &&
        Math.abs(last_z - z) < idle_threshold)
    {
        if (state == STATE_FAST || state == STATE_BUILD)
        {
            idle_count++;
            if (idle_count > idle_loops)
            {
                build_gain.gain.value = 0;
                drop_gain.gain.value = 0;
                fast_gain.gain.value = 0;
                console.log("idle");
                state = STATE_IDLE;
            }
        }
    }
    else
    {
        idle_count = 0;
        if (state == STATE_IDLE)
        {
            state = STATE_BUILD;
            build_gain.gain.value = osc_volume;
            drop_gain.gain.value = 0;
            fast_gain.gain.value = 0;
        }
    }

    m = Math.sqrt((x * x) + (y * y) + (z * z));
    if (state == STATE_BUILD && last_m - m > drop_threshold)
    {
        state = STATE_DROP;
        drop_gain.gain.value = osc_volume;
        build_gain.gain.value = 0;
        fast_gain.gain.value = 0;
        drop_t = t;
    }

    if (state == STATE_DROP && t - drop_t > drop_duration)
    {
        state = STATE_FAST;
        drop_gain.gain.value = 0;
        build_gain.gain.value = 0;
        fast_gain.gain.value = osc_volume;
        drop_t = 0;
    }

//    f = 50+ (z * 5);
//    osc.frequency.value = f;

//    f = 50 + (z * 5);
//    osc2.frequency.value = f;
//    f = 750 + (10 * z);
//    lowpass.frequency.value = f;
//    console.log(f);
    // 50 - 1500 range

    last_x = x;
    last_y = y;
    last_z = z;
    last_m = m;
}

$(document).ready(function() 
{
    namespace = '/pendulum'; 
    var socket = io.connect('http://' + document.domain + ':' + location.port + namespace);
    socket.on('data', function(msg) {
        d = msg.data.split(",");
        handler(parseInt(d[0]), parseInt(d[1]), parseInt(d[2]), parseInt(d[3]));
    });
});

</script>
</body>
</html>
